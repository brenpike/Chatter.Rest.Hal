using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Chatter.Rest.Hal.CodeGenerators;

internal class Emitter
{
	internal static void Emit(SourceProductionContext context,
		ImmutableArray<ClassDeclarationSyntax?> halResponseClasses)
	{
		if (halResponseClasses.IsDefaultOrEmpty)
		{
			return;
		}

		var distinctClasses = halResponseClasses.NotNull().Distinct();

		foreach (var type in distinctClasses)
		{
			AddSource(context, type);
		}
	}

	private static void AddSource(SourceProductionContext context, ClassDeclarationSyntax type)
	{
		var ns = GetNamespaceFrom(type);
		var name = type.Identifier.Text;
		var code = GenerateCode(name, ns);
		var typeNamespace = ns is null ? string.Empty : $"{ns}.";
		context.AddSource($"{typeNamespace}{name}.g.cs", code);
	}

	private static string GenerateCode(string name, string? ns) =>
		@$"// <auto-generated />

using System.Text.Json;
using System.Text.Json.Serialization;
using Chatter.Rest.Hal;

#nullable enable

{(ns is null ? null : $@"namespace {ns}
{{")}
    partial class {name}
    {{
        [JsonPropertyName(""_links"")]
	    public LinkCollection? Links {{ get; set; }}
	    [JsonPropertyName(""_embedded"")]
	    public EmbeddedResourceCollection? Embedded {{ get; set; }}
    }}
{(ns is null ? null : @"}
")}";

	private static string? GetNamespaceFrom(SyntaxNode s) =>
		s.Parent switch
		{
			FileScopedNamespaceDeclarationSyntax fileScopedNamespace => fileScopedNamespace.Name.ToString(),
			NamespaceDeclarationSyntax namespaceDeclarationSyntax => namespaceDeclarationSyntax.Name.ToString(),
			null => null,
			_ => GetNamespaceFrom(s.Parent)
		};
}