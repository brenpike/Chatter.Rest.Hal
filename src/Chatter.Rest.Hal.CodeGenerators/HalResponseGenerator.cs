using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
#if DEBUG
using System.Diagnostics;
#endif

namespace Chatter.Rest.Hal.CodeGenerators;

[Generator]
public class HalResponseGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
//#if DEBUG
//		if (!Debugger.IsAttached)
//		{
//			Debugger.Launch();
//		}
//#endif
		var halResponseTypes = context.SyntaxProvider
			.CreateSyntaxProvider(CouldBeHalResponse, GetAttributeTypeOrNull)
			.Where(type => type is not null)
			.Collect();
		context.RegisterSourceOutput(halResponseTypes, GenerateCode);
	}

	private static bool CouldBeHalResponse(SyntaxNode syntaxNode, CancellationToken cancellationToken)
	{
		if (syntaxNode is not AttributeSyntax attribute)
		{
			return false;
		}

		var name = ExtractName(attribute.Name);

		return name is "HalResponse" or "HalResponseAttribute";
	}

	private static string? ExtractName(NameSyntax? name)
	{
		while (name != null)
		{
			switch (name)
			{
				case IdentifierNameSyntax ins:
					return ins.Identifier.Text;

				case QualifiedNameSyntax qns:
					name = qns.Right;
					break;

				default:
					return null;
			}
		}

		return null;
	}

	private static ITypeSymbol? GetAttributeTypeOrNull(GeneratorSyntaxContext context,
		CancellationToken cancellationToken)
	{
		var attributeSyntax = (AttributeSyntax)context.Node;

		// "attribute.Parent" is "AttributeListSyntax"
		// "attribute.Parent.Parent" is a C# fragment the attributes are applied to
		if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
		{
			return null;
		}

		return context.SemanticModel.GetDeclaredSymbol(classDeclaration) is not ITypeSymbol type || !IsHalResponse(type)
			? null
			: type;
	}

	private static bool IsHalResponse(ISymbol type) =>
		type.GetAttributes()
			.Any(a => a.AttributeClass?.Name == "HalResponseAttribute" &&
			          a.AttributeClass.ContainingNamespace is
			          {
				          Name: "Hal",
				          ContainingNamespace :
				          {
					          Name: "Rest",
					          ContainingNamespace:
					          {
						          Name: "Chatter",
						          ContainingNamespace.IsGlobalNamespace: true
					          }
				          }
			          });

	private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol?> halResponses)
	{
		if (halResponses.IsDefaultOrEmpty)
		{
			return;
		}

		foreach (var type in halResponses.Where(t => t is { }))
		{
			var code = GenerateCode(type);
			var typeNamespace = type!.ContainingNamespace.IsGlobalNamespace
				? null
				: $"{type.ContainingNamespace}.";

			context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
		}
	}

	private static string GenerateCode(ITypeSymbol? type)
	{
		if (type is not { })
		{
			return string.Empty;
		}

		var ns = type.ContainingNamespace.IsGlobalNamespace
			? null
			: type.ContainingNamespace.ToString();
		var name = type.Name;

		return @$"// <auto-generated />

using System.Text.Json;
using System.Text.Json.Serialization;
using Chatter.Rest.Hal;

{(ns is null ? null : $@"namespace {ns}
{{")}
    partial class {name}
    {{
        [JsonPropertyName(""_links"")]
	    public LinkCollection? Links {{ get; set; }}
	    [JsonPropertyName(""_embedded"")]
	    public EmbeddedResourceCollection? Embedded {{ get; set; }}
    }}
{(ns is null ? null : @"}
")}";
	}
}